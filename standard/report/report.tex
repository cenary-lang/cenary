\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{listings}

\title{Cmpe491 Midterm Progress Report}
\author{Yiğit Özkavcı}
\date{October 2017}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduction}
\par 
\par This is the midterm report for project Ivy, a programming language for writing smart contracts on Ethereum Virtual Machine.
\par Ethereum is a decentralized plaform that runs smart contracts: pieces of codes that have the ability to run on any blockchain network. In order to write smart contracts, one should deploy a EVM-executable bytecode into blockchain network, which is not practical since bytecode is a sequence of hex characters; nothing more. To overcome this problem, EVM-compatible programming languages are being designed in order to abstract the problem of having to deploy plain bytecode. 
\par There are already programming languages targeting EVM, including Solidity\cite{solidity}, Bamboo\cite{bamboo} and Viper\cite{viper}; and Ivy is planning to be a programming language that is easy to use, ability to scale with abstractions and capable of generating an optimised bytecode.

\section{Language Constraints by EVM}
Designing a programming language while targeting EVM has several problems that general purpose programming languages don't. In this section, we will investigate problems that we have / may encounter.

\subsection{Gas Cost}
\par Basically, in order to run compurations on a blockchain via smart contracts, one should pay \textbf{enough or more} gas. But\ldots what is gas? Gas is an alias for Wei, the smallest unit of subdenomination of Ether. Below are differend kinds of subdenominations and their multiplier of Wei.

\begin{table}[h]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    \textbf{Wei Multiplier} & \textbf{Name} \\
    \hline
    $ 10^0 $ & Wei \\
    \hline
    $ 10^12 $ & Szabo \\
    \hline
    $ 10^15 $ & Finney \\
    \hline
    $ 10^18 $ & Ether \\
    \hline
  \end{tabular}
  \caption{Ether Subdenominations}
  \label{tab:ether_subdenominations}
\end{table}
\par Gas is the pricing of computations that are run by smart contracts. Basically, each interaction via a smart contract must be paid in units of gas. This also means that the higher abstraction level we have for EVM computations, the more costly our computations will be, because of the abstraction layer switch of the compiler.
\newpage
\par This is where compiler optimizations are critically important. In the context of smart contracts, compiler optimization is not just about how much of the RAM or CPU of the user you consume, but also the real money of the user you waste in the runtime. We will investigate optimisations in terms of stack operations (see \ref{subsec:stack}) and memory allocations (see \ref{subsec:memory}) in further sections.

\subsection{Entrance Point}
\par A smart contract has two main phases in its life time: construction and listening. We will illustrate both of them in the following sections, and also explain how to adapt these two distinch phases into Ivy's strategy of logic flow.
\subsubsection{Construction}
\label{subsubsec:construction}
\par When a smart contract is deployed on EVM, a code is being executed in the same fashion Java\cite{java} constructs instances of objects described in their class. In this phase, an EVM-oriented programming language should give programmer the address information of the deployer, and let user do whatever they want with it. Typically, users set that address information in object-oriented EVM-targeting languages like Solidity\cite{solidity}
\par This phase is one shot: meaning construction phase will be terminated once it finishes its execution. It's programmer's responsibility to use this initial phase according to the program's needs.
\subsubsection{Code to execute upon receiving a message}
\par The more interesting phase is the second phase. As we said before, a smart contract is not like a terminating program, but an executable (see \ref{subsec:message_sending}) with internal state (see \ref{subsec:stack} and \ref{subsec:memory}). Hence, a program written in a language shall implement a parametric and callable interface which can be run from outer world.
\par Not every call to a contract shall necessarily change the internal state of it. There are mainly two kinds of messages: reading data from the state and updating it. Reading data doesn't cost any gas, but updating the state surely does.
\subsection{Message Sending}
If one wants to read or update data on a smart contract, they should execute a procedure on that contract. As we noted before, contract should describe this executable code interface on construction phase (see \ref{subsubsec:construction}). Say we have the following interface for our contract:
\newpage
\lstinputlisting[firstline=1, language=Java]{code/ContractInterface.java}
\label{subsec:message_sending}
\section{Optimisations}
\subsection{Stack}
\label{subsec:stack}
\subsection{Memory}
\label{subsec:memory}
\section{Implementation}
\subsection{Lexing}
\label{subsec:lexing}
\subsection{Parsing}
\label{subsec:parsing}
\subsection{Type Checking}
\label{subsec:type_checking}
\subsection{Code Generation}
\label{subsec:code_generation}
\subsection{Optimisation Passes}
\label{subsec:optimisation_passes}

\begin{thebibliography}{9}

\bibitem{solidity}
  Solidity: Contract-Oriented Programming Language, https://github.com/ethereum/solidity
\bibitem{bamboo}
  Bamboo: a morphing smart contract language, https://github.com/pirapira/bamboo
\bibitem{viper}
  Viper: an experimental programming language targeting EVM, https://github.com/ethereum/viper
\bibitem{java}
  https://en.wikipedia.org/wiki/Java\_(programming\_language)

\end{thebibliography}

\end{document}
